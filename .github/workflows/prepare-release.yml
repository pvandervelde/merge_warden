# Workflow to prepare a release pull request
name: Prepare Release PR

on:
  push:
    branches:
      - master

permissions:
  contents: write # To push branches, commit changes
  pull-requests: write # To create/close PRs

jobs:
  prepare-release:
    name: Prepare Release PR
    runs-on: ubuntu-latest
    # Skip if the commit message indicates it's from merging a release PR
    if: ${{ !contains(github.event.head_commit.message, 'chore(release):') }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Fetch all history for version calculation and changelog generation
          fetch-depth: 0

      - name: Set up Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo binstall
        uses: cargo-bins/cargo-binstall@main

      - name: Install Conventional Commits Next Version
        run: cargo install conventional_commits_next_version

      - name: Install git-cliff
        run: cargo install git-cliff

      - name: Install cargo typos
        run: cargo install typos-cli

      - name: Configure Git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Calculate next version
        id: calc_version
        run: |
          # Use Conventional Commits Next Version to calculate the next version
          NEXT_VERSION=$(conventional_commits_next_version --from-commit-hash $(git rev-parse $(git describe --tags --abbrev=0)) --from-version $(git describe --tags --abbrev=0) --calculation-mode "Batch")
          echo "NEXT_VERSION=${NEXT_VERSION}" >> $GITHUB_OUTPUT
          echo "The next version is: ${NEXT_VERSION}"

      - name: Handle stale release branches
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEXT_VERSION="${{ steps.calc_version.outputs.NEXT_VERSION }}"
          echo "Next calculated version: ${NEXT_VERSION}"
          # List all remote release branches
          git fetch origin 'refs/heads/release/*:refs/remotes/origin/release/*'
          for branch in $(git branch -r --list 'origin/release/*' | sed 's|origin/||'); do
            # Extract version from branch name (e.g., release/1.2.3 -> 1.2.3)
            branch_version=$(echo "$branch" | sed 's|release/||')
            echo "Found existing release branch: ${branch} (version: ${branch_version})"

            if [[ "$branch_version" != "$NEXT_VERSION" ]]; then
              echo "Branch ${branch} is stale (version ${branch_version} != ${NEXT_VERSION}). Cleaning up..."
              # Find PR associated with the stale branch
              PR_NUMBER=$(gh pr list --head "$branch" --state open --json number --jq '.[0].number // empty')
              if [[ -n "$PR_NUMBER" ]]; then
                echo "Closing PR #${PR_NUMBER} for stale branch ${branch}..."
                gh pr close "$PR_NUMBER" --comment "Closing stale release PR as version ${NEXT_VERSION} is now being prepared."
              else
                echo "No open PR found for stale branch ${branch}."
              fi
              # Delete the stale remote branch
              echo "Deleting stale remote branch ${branch}..."
              git push origin --delete "$branch"
            fi
          done

      - name: Check if release branch already exists
        id: check_branch
        run: |
          NEXT_VERSION="${{ steps.calc_version.outputs.NEXT_VERSION }}"
          BRANCH_NAME="release/${NEXT_VERSION}"
          if git rev-parse --verify --quiet "origin/${BRANCH_NAME}"; then
            echo "Branch ${BRANCH_NAME} already exists."
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Branch ${BRANCH_NAME} does not exist."
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate Changelog Section
        id: generate_changelog
        run: |
          NEXT_VERSION="${{ steps.calc_version.outputs.NEXT_VERSION }}"
          # Generate notes for the upcoming version
          # Use the tag format decided earlier (no 'v' prefix)
          git-cliff --tag "${NEXT_VERSION}" --unreleased --strip all > release_notes.md
          echo "Generated release notes for ${NEXT_VERSION}"
          # Check if notes were actually generated (might be empty if no relevant commits)
          if [ -s release_notes.md ]; then
            echo "has_notes=true" >> $GITHUB_OUTPUT
          else
            echo "No relevant commits found for changelog."
            echo "has_notes=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Node.js
        if: steps.generate_changelog.outputs.has_notes == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate GitHub App token
        if: steps.generate_changelog.outputs.has_notes == 'true'
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      - name: Prepare release with verified commit and PR
        if: steps.generate_changelog.outputs.has_notes == 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          node .github/scripts/prepare-release.js "${{ steps.calc_version.outputs.NEXT_VERSION }}" release_notes.md
